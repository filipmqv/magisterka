#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ../../texmf/tex/latex/commonstuff/dcsbook
\begin_preamble
%
%  $Id: thesis-template.lyx,v 1.7 2011/12/22 12:10:18 sobaniec Exp $
%
\usepackage{etoolbox}

\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}
\patchcmd{\ttlh@hang}{\noindent}{}{}{}
\makeatother
\end_preamble
\options thesis, openany
\use_default_options false
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbph
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "urlcolor=linkcolor,linkcolor=linkcolor,citecolor=linkcolor"
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
Filip Waligórski
\end_layout

\begin_layout Title
Rozgłaszanie danych w
\begin_inset space ~
\end_inset

grafach dużej skali
\end_layout

\begin_layout Date
Poznań, 2017
\end_layout

\begin_layout Supervisor
dr Anna Kobusińska
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subtitle
Bachelor's Thesis
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frontmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Wstęp
\end_layout

\begin_layout Chapter
Istniejące rozwiązania
\end_layout

\begin_layout Standard
W tym rozdziale zaprezentowano istniejące komunikatory dla dwóch osób oraz
 komunikatory grupowe.
 Ich cele i
\begin_inset space ~
\end_inset

funkcjonalność są zbliżone choć realizują je z
\begin_inset space ~
\end_inset

różnymi założeniami oraz bazując na różnych architekturach i
\begin_inset space ~
\end_inset

koncepcjach.
 Poniżej opisane zostały wybrane rozwiązania z
\begin_inset space ~
\end_inset

naciskiem na cechy wyróżniające je spośród konkurencyjnych aplikacji.
 
\end_layout

\begin_layout Section
Facebook Messenger 
\begin_inset CommandInset citation
LatexCommand cite
key "messenger"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:messenger"

\end_inset


\end_layout

\begin_layout Standard
Jest to jeden z
\begin_inset space ~
\end_inset

najpopularniejszych obecnie komunikatorów.
 Oferuje zarówno rozmowy dla 2 osób jak i
\begin_inset space ~
\end_inset

grupowe.
 Wspiera wysyłanie wszelkich multimediów i
\begin_inset space ~
\end_inset

plików oraz dostarczanie wiadomości pod nieobecność nadawcy.
 Dostępny jest na najszerszej gamie platform — jako aplikacja webowa, mobilna
 oraz desktopowa, czym wyróżnia się na tle konkurencji.
 Architektonicznie Messenger polega na 
\begin_inset Quotes pld
\end_inset

centralnym serwerze
\begin_inset Quotes prd
\end_inset

 przekazującym wiadomości.
 Cudzysłów wynika z
\begin_inset space ~
\end_inset

faktu, że pod pojęciem 
\begin_inset Quotes pld
\end_inset

serwer
\begin_inset Quotes prd
\end_inset

 kryje się ogromna infrastruktura złożona z
\begin_inset space ~
\end_inset

wielu maszyn, którą firma musi utrzymywać.
 Wadą tego komunikatora jest brak domyślnego wsparcia szyfrowania wiadomości
 — opcję można włączyć tylko w aplikacji mobilnej dla poszczególnych konwersacji
, jednak nie każdy użytkownik jest tej opcji świadomy.
 Szyfrowanie w aplikacji webowej nie jest dostępne 
\begin_inset CommandInset citation
LatexCommand cite
key "messenger-encryption"

\end_inset

.
 Kod źródłowy aplikacji nie został udostępniony (nie jest to open-source),
 co oznacza, że za wprowadzanie zmian i dodawanie nowych funkcji odpowiedzialny
 jest tylko wydawca — społeczność użytkowników nie ma możliwości ingerowania
 w funkcjonalność.
 Jest to wada w sytuacji, gdy nowa wersja oprogramowania zawiera niechciane
 przez użytkowników dodatki (zbędne lub na przykład szpiegujące), a nie
 zawiera takich, które są przez nich wyczekiwane.
\end_layout

\begin_layout Section
Bleep 
\begin_inset CommandInset citation
LatexCommand cite
key "bleep"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bleep"

\end_inset


\end_layout

\begin_layout Standard
Bleep jest komunikatorem zaprojektowanym przez firmę rozwijającą protokół
 BitTorrent.
 Do dyspozycji użytkowników oddano aplikację mobilną oraz aplikację desktopową
 (brak aplikacji webowej).
 Podobnie jak w przypadku Messengera z poprzedniego punktu, nie jest to
 oprogramowanie open-source.
 Bleep oferuje rozmowy dla dwóch osób, a
\begin_inset space ~
\end_inset

w
\begin_inset space ~
\end_inset

planach twórców jest zaimplementowanie komunikacji grupowej.
 Wiadomości są szyfrowane przed wysłaniem na urządzeniu nadawcy i
\begin_inset space ~
\end_inset

odszyfrowywane na urządzeniu odbiorcy — szyfrowanie end to end.
 
\end_layout

\begin_layout Standard
Jednak najważniejszą cechą wyróżniającą ten komunikator jest jego architektura
 - brak centralnego serwera pośredniczącego w
\begin_inset space ~
\end_inset

przekazywaniu wiadomości.
 Komunikaty przesyłane są bezpośrednio między urządzeniami, jeśli oba są
 dostępne w
\begin_inset space ~
\end_inset

momencie wysyłania, a
\begin_inset space ~
\end_inset

w
\begin_inset space ~
\end_inset

przeciwnym przypadku wiadomość umieszczana jest w
\begin_inset space ~
\end_inset

DHT (Distributed Hash Table) i
\begin_inset space ~
\end_inset

przechowywana do czasu odebrania jej.
 Specjalny mechanizm dba o
\begin_inset space ~
\end_inset

to, by wiadomość nie zniknęła z
\begin_inset space ~
\end_inset

DHT wcześniej.
 Dane o
\begin_inset space ~
\end_inset

koncie użytkownika oraz klucze szyfrujące pozostają lokalnie na urządzeniu.
 
\end_layout

\begin_layout Section
Signal 
\begin_inset CommandInset citation
LatexCommand cite
key "signal"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:signal"

\end_inset


\end_layout

\begin_layout Standard
Twórcy aplikacji Signal skupili się przede wszystkim na bezpieczeństwie
 i
\begin_inset space ~
\end_inset

prywatności użytkowników.
 Wiadomości są szyfrowane na urządzeniach, więc pomimo faktu, że architektura
 zakłada obecność centralnego serwera, wiadomości przechowywane na nim nie
 mogą zostać odczytane przez osoby trzecie.
 Jednakże, ten typ architektury posiada znaczącą wadę — jeśli serwer stanie
 się niedostępny (na przykład z powodu jego awarii lub braku łączności z
 nim — awarii łącza komunikacyjnego) to niemożliwe jest prowadzenie rozmów
 (dotyczy to każdej aplikacji z centralnym serwerem).
 Kod źródłowy jest dostępny publicznie co oznacza, że każdy może sprawdzić
 zgodność implementacji z
\begin_inset space ~
\end_inset

oferowanymi założeniami.
 Podobnie jak w
\begin_inset space ~
\end_inset

przypadku aplikacji Bleep, dostępne są natywne aplikacje mobilna i
\begin_inset space ~
\end_inset

desktopowa.
 Możliwe jest prowadzenie rozmowy grupowej pomimo zastosowania szyfrowania
 wiadomości — treść zostaje zaszyfrowana symetrycznie (jedna wersja dla
 wszystkich odbiorców niezależnie od ich liczby), a
\begin_inset space ~
\end_inset

następnie sam klucz jest szyfrowany zgodnie z
\begin_inset space ~
\end_inset

oczekiwaniami każdego z
\begin_inset space ~
\end_inset

odbiorców z
\begin_inset space ~
\end_inset

osobna.
 Dzięki temu mechanizmowi uniknięto sytuacji, w
\begin_inset space ~
\end_inset

której nadawca musiałby przygotować 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
n
\end_layout

\end_inset

 wersji całej, potencjalnie dużej wiadomości dla 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
n
\end_layout

\end_inset

 odbiorców.
\end_layout

\begin_layout Standard
Podobne rozwiązania: Wire, WhatsApp, Telegram, Allo
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO osobno whatsapp - jego sposób na apkę webową, skoro można mieć tylko
 jednego klienta na konto i serwer zapomina wiadomości, które zostały dostarczon
e do wszystkich to jak to jest zrobione - telefon przekazuje do przeglądarki
 (szyfrowanie jest tylko w telefonie i on pośredniczy w rozmowie jeśli ktoś
 ją prowadzi z aki webowej)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Darkwire 
\begin_inset CommandInset citation
LatexCommand cite
key "darkwire"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Darkwire"

\end_inset


\end_layout

\begin_layout Standard
Darkwire to aplikacja open-source oferująca komunikator grupowy z
\begin_inset space ~
\end_inset

dostępem poprzez stronę internetową (aplikacja webowa).
 W przeciwieństwie do większości rozwiązań użytkownik nie musi tworzyć konta
 by skorzystać z
\begin_inset space ~
\end_inset

programu.
 W celu skomunikowania się z
\begin_inset space ~
\end_inset

użytkownikami należy wymienić między nimi identyfikator konwersacji (link
 do konkretnego pokoju) korzystając z innego sposobu komunikacji (np.
 poprzez e-mail, SMS czy osobiście).
 Takie rozwiązanie zakłada, że identyfikator nie zostanie odgadnięty przez
 osoby trzecie — w
\begin_inset space ~
\end_inset

przeciwnym przypadku będą one mogły odczytać wysyłane wiadomości.
 Architektura zakłada istnienie centralnego serwera uczestniczącego w
\begin_inset space ~
\end_inset

przekazywaniu wiadomości.
 Z racji faktu, że aplikacja ma otwarte źródła, każdy może uruchomić swój
 własny serwer.
 Komunikaty są szyfrowane na urządzeniu (w
\begin_inset space ~
\end_inset

przeglądarce) przed wysłaniem, zatem serwer nie zna treści wiadomości.
 Centralny serwer przesyła wiadomości tylko do tych uczestników, którzy
 są dostępni w
\begin_inset space ~
\end_inset

momencie nadania wiadomości (brak wsparcia dla odbierania starszych wiadomości
 czy wysyłania wiadomości do użytkowników niedostępnych w
\begin_inset space ~
\end_inset

danej chwili).
 
\end_layout

\begin_layout Section
Friends 
\begin_inset CommandInset citation
LatexCommand cite
key "friends"

\end_inset


\end_layout

\begin_layout Standard
Ten niszowy projekt open-source oferuje aplikację desktopową i
\begin_inset space ~
\end_inset

umożliwia prowadzenie rozmów grupowych.
 Szyfrowanie wiadomości nie zostało do tej pory zrealizowane, ale jest jednym
 z
\begin_inset space ~
\end_inset

punktów przyszłego rozwoju.
 Głównym celem twórców było stworzenie programu niezależnego od centralnego
 serwera oraz umożliwiającego rozmowę przy użyciu alternatywnych kanałów
 komunikacyjnych (np.
 poprzez Bluetooth) w
\begin_inset space ~
\end_inset

sytuacji gdy połączenie internetowe jest niedostępne.
 Aplikacja wykorzystuje algorytm plotkowania (gossiping) oraz replikuje
 wiadomości przy użyciu drzewa skrótów (hash tree, Merkle DAG, DAG - Directed
 Acyclic Graph 
\begin_inset CommandInset citation
LatexCommand cite
key "merkle"

\end_inset

).
 Dzięki temu wiadomości w
\begin_inset space ~
\end_inset

konwersacji mogą zostać połączone nawet w
\begin_inset space ~
\end_inset

przypadku, gdy ktoś nadał komunikaty będąc odłączonym od sieci — mechanizm
 podobny do łączenia zmian w
\begin_inset space ~
\end_inset

repozytorium kodu.
 Wykorzystanie opisanych powyżej mechanizmów gwarantuje ostateczną spójność
 otrzymanych wiadomości — każdy uczestnik rozmowy ostatecznie będzie widział
 taki sam zbiór wiadomości — przykładowy scenariusz dla 3 użytkowników:
 
\end_layout

\begin_layout Enumerate
Wiadomość wysłana przez użytkownika A została odebrana przez użytkownika
 B, który dołączył ją do swojego drzewa wiadomości.
 
\end_layout

\begin_layout Enumerate
Użytkownik A stał się niedostępny.
 
\end_layout

\begin_layout Enumerate
Użytkownik C stał się dostępny i
\begin_inset space ~
\end_inset

odebrał od użytkownika B zmienioną wersję drzewa i
\begin_inset space ~
\end_inset

w
\begin_inset space ~
\end_inset

ten sposób dowiedział się o
\begin_inset space ~
\end_inset

wiadomości wysłanej przez użytkownika A pomimo faktu, że ten jest w
\begin_inset space ~
\end_inset

tej chwili niedostępny.
 
\end_layout

\begin_layout Section
Tox 
\begin_inset CommandInset citation
LatexCommand cite
key "tox"

\end_inset


\end_layout

\begin_layout Standard
Tox jest z
\begin_inset space ~
\end_inset

założenia rozproszonym i
\begin_inset space ~
\end_inset

szyfrowanym protokołem do wymiany wiadomości.
 Powstało kilkanaście implementacji klientów obsługujących go, co pozwala
 na komunikowanie się z
\begin_inset space ~
\end_inset

użytkownikami różnych aplikacji.
 Wśród zaimplementowanych aplikacji są programy na komputery stacjonarne
 oraz smartfony.
 Wiadomości są przesyłane bezpośrednio między nadawcą i
\begin_inset space ~
\end_inset

odbiorcą dlatego obie strony muszą być dostępne jednocześnie.
 Brak wsparcia dostarczania wiadomości gdy jedna strona jest niedostępna
 to duża wada wszystkich aplikacji implementujących wskazany powyżej rodzaj
 transmisji P2P.
 Jednym z
\begin_inset space ~
\end_inset

rozwiązań tego problemu zaproponowanym przez twórców protokołu jest skorzystanie
 z
\begin_inset space ~
\end_inset

serwerów, którym użytkownik ufa i
\begin_inset space ~
\end_inset

których zadaniem jest przekazywanie wiadomości do odbiorcy pod nieobecność
 nadawcy.
 Narusza to jednak założenie o
\begin_inset space ~
\end_inset

rozproszeniu systemu (braku centralnych węzłów).
 Wsparcie dla komunikacji grupowej jest jednym z
\begin_inset space ~
\end_inset

celów rozwoju protokołu.
 
\end_layout

\begin_layout Section
ZeroChat, ZeroMail, BitMessage 
\begin_inset CommandInset citation
LatexCommand cite
key "zeronet"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bitmessage-main"

\end_inset


\end_layout

\begin_layout Standard
Przytoczone aplikacje realizują pomysły na komunikatory bazujące na mechanizmie
 podobnym do transakcji kryptowalutowych.
 Wysłanie wiadomości wymaga umieszczenia wiadomości w bloku, obliczenia
 funkcji skrótu z
\begin_inset space ~
\end_inset

zadanym prefiksem (proof of work) i
\begin_inset space ~
\end_inset

umieszczenia bloku w
\begin_inset space ~
\end_inset

łańcuchu (blockchain).
 Samo tylko wyliczenie funkcji skrótu powinno z
\begin_inset space ~
\end_inset

definicji zająć około 4 minut 
\begin_inset CommandInset citation
LatexCommand cite
key "bitmessage-pdf"

\end_inset

, podczas gdy pozostałe komunikatory dążą do uzyskania czasu dostarczenia
 wiadomości bliskiego zeru (rozmowa w
\begin_inset space ~
\end_inset

czasie rzeczywistym).
 Mimo tej znaczącej wady należy potraktować te projekty jako próbę stworzenia
 rozwiązania o
\begin_inset space ~
\end_inset

innej architekturze niż dotychczas zaprezentowane (centralny serwer lub
 P2P).
 Przykładowymi zaletami architektury blockchain są: brak centralnego serwera
 lub centrów danych, nad którymi kontrolę ma jedna firma decydująca o sposobie
 ich działania lub ich wyłączeniu, skalowalność oraz brak możliwości ingerencji
 w zapisane dane — wraz z upływem czasu maleje prawdopodobieństwo, że treść
 wiadomości zapisana w blockchainie ulegnie zmianie (wynika to wprost z
 własności tej technologii).
 Być może w
\begin_inset space ~
\end_inset

przyszłości wady uda się zminimalizować, a
\begin_inset space ~
\end_inset

zalety architektury blockchain okażą się kluczowe.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO tabelka porównawcza, serwer, szyfrowanie, platformy, łatwość prowadzenia
 rozmów (czy np trzeba wymienić się czymś wcześniej innym sposobem czy od
 razu można zacząć gadać (np bez konta), czy konto wymagane, jakie dane
 przekazujemy firmie, wiadomości grupowe?, 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Koncepcja
\end_layout

\begin_layout Standard
W niniejszym rozdziale opisano technologie i protokoły wykorzystane do opracowan
ia koncepcji i implementacji rozproszonego komunikatora grupowego.
 Konkretnie, są to: protokół BitTorrent przedstawiony w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:bittorent"

\end_inset

 oraz jego implementacja w języku JavaScript — WebTorrent — punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:webtorrent"

\end_inset

.
 
\end_layout

\begin_layout Section
BitTorrent 
\begin_inset CommandInset citation
LatexCommand cite
key "bittorrent"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bittorent"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO co ja wykorzystuję z tego?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
BitTorrent to protokół komunikacyjny pozwalający na wymianę i dystrybucję
 plików przez Internet.
 Jego główną zaletą jest podział plików na części i możliwość pobierania
 tych części od użytkowników, którzy w danym momencie również uczestniczą
 w procesie udostępniania.
 Pozwala to na znaczne odciążenie serwera.
 W szczególności możliwe jest nawet wyłączenie serwera, a plik pozostanie
 dostępny do pobrania, jeśli tylko wszystkie jego fragmenty zostały przed
 wyłączeniem rozesłane do zainteresowanych komputerów (wystarczy, że jedna
 maszyna posiada daną część i podzieli się nią z pozostałymi).
 
\end_layout

\begin_layout Subsection
Podstawowe pojęcia
\end_layout

\begin_layout Standard
Poniżej znajduje się lista najważniejszych pojęć związanych z protokołem
 wraz z krótkim wyjaśnieniem ich znaczenia:
\end_layout

\begin_layout Itemize
torrent — plik lub zbiór plików udostępnionych do pobrania.
\end_layout

\begin_layout Itemize
metaplik .torrent (.torrent metafile) — dodatkowy plik z metadanymi dotyczącymi
 udostępnionych plików.
 Zawiera między innymi:
\end_layout

\begin_deeper
\begin_layout Itemize
nazwy i rozmiary plików, 
\end_layout

\begin_layout Itemize
liczbę i rozmiar fragmentów, na jakie zostały podzielone pliki, 
\end_layout

\begin_layout Itemize
listę skrótów SHA-1 fragmentów w celu weryfikacji poprawności,
\end_layout

\begin_layout Itemize
adresy URL trackerów.
\end_layout

\end_deeper
\begin_layout Itemize
piece, block — podczas przygotowywania torrenta pliki dzielone są na fragmenty
 (piece), a każdy taki fragment składa się z bloków (block).
 Blok jest najmniejszą jednostką, którą można przesłać przez sieć między
 użytkownikami.
 Aby udostępniać fragment użytkownik musi posiadać wszystkie jego bloki.
 
\end_layout

\begin_layout Itemize
info hash — 160-bitowa wartość będąca wynikiem funkcji skrótu SHA-1, której
 podawana jest część metapliku .torrent (nazwy plików i lista skrótów fragmentów).
 Info hash pozwala jednoznacznie zidentyfikować dany torrent.
 
\end_layout

\begin_layout Itemize
tracker — serwer, którego zadaniem jest przechowywanie adresów IP użytkowników
 pobierających dany torrent.
 Pozwala użytkownikom na znalezienie siebie nawzajem.
 
\end_layout

\begin_layout Itemize
klient (client) — program uruchomiony na komputerze użytkownika, który pozwala
 na pobieranie plików z wykorzystaniem protokołu BitTorrent.
\end_layout

\begin_layout Itemize
peer — węzeł (komputer, klient) pobierający i wysyłający fragmenty torrenta.
 Zazwyczaj nie posiada jeszcze wszystkich fragmentów.
\end_layout

\begin_layout Itemize
seed — peer posiadający wszystkie fragmenty.
 
\end_layout

\begin_layout Itemize
swarm — grupa peerów pobierających dany torrent.
\end_layout

\begin_layout Itemize
peer-to-peer (P2P) — sieć złożona z komputerów, które komunikują się ze
 sobą np.
 w celu wymiany plików.
 Peery tworzą sieć P2P.
\end_layout

\begin_layout Itemize
Distributed Hash Table (DHT) — rozproszona tablica mieszająca — sieć składająca
 się z węzłów, które umożliwiają zapisywanie i odczytywanie rekordów w formie
 klucz-wartość.
 Węzły dzielą między sobą zbiór wszystkich kluczy.
 W kontekście protokołu BitTorrent, DHT może zastąpić rolę trackera.
\end_layout

\begin_layout Itemize
magnet link — link pozwalający na uzyskanie metadanych torrenta bez konieczności
 pobierania metapliku .torrent.
 Link powinien zawierać przynajmniej info hash torrenta oraz listę trackerów.
\end_layout

\begin_layout Subsection
Scenariusz pobrania torrenta
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scenariusz pobrania torrenta"

\end_inset


\end_layout

\begin_layout Standard
W celu pobrania torrenta niezbędne są następujące czynności:
\end_layout

\begin_layout Enumerate
Pobranie metapliku .torrent lub poznanie (kliknięcie) magnet linku identyfikujące
go dany torrent.
 Zazwyczaj informacje te można uzyskać na stronach internetowych katalogujących
 istniejące torrenty (wyszukiwarkach torrentów).
\end_layout

\begin_layout Enumerate
Uzyskanie listy trackerów z metapliku lub magnet linka.
\end_layout

\begin_layout Enumerate
Pobranie z trackera listy peerów uczestniczących w udostępnianiu torrenta.
\end_layout

\begin_layout Enumerate
Pobranie fragmentów torrenta od peerów.
\end_layout

\begin_layout Subsection
Scenariusz utworzenia torrenta
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scenariusz utworzenia torrenta"

\end_inset


\end_layout

\begin_layout Standard
W celu udostępnienia torrenta należy:
\end_layout

\begin_layout Enumerate
Stworzyć metaplik .torrent dla udostępnianych treści oraz utworzyć listę
 trackerów, które będą nadzorowały pobieranie treści.
\end_layout

\begin_layout Enumerate
Rozpocząć udostępnianie torrenta.
\end_layout

\begin_layout Enumerate
Umieścić metaplik .torrent w miejscu, z którego zainteresowani będą mogli
 go pobrać (np.
 na zewnętrznym serwerze).
 Alternatywnie można rozpowszechnić magnet link lub sam info hash — w ostatniej
 sytuacji osoba zainteresowana pobraniem torrenta musi znać listę trackerów,
 które koordynują pobieranie.
 
\end_layout

\begin_layout Subsection
Jak komunikują się peery
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:jak-komunikuja"

\end_inset


\end_layout

\begin_layout Standard
BitTorrent używa 12 typów wiadomości do prowadzenia komunikacji pomiędzy
 peerami:
\end_layout

\begin_layout Itemize
hand-shake — wiadomość rozpoczynająca połączenie,
\end_layout

\begin_layout Itemize
bitfield — wskazuje, jakie fragmenty posiada peer, 
\end_layout

\begin_layout Itemize
keep-alive — wiadomość podtrzymująca otwarte połączenie, 
\end_layout

\begin_layout Itemize
port — informuje o zmianie portu, 
\end_layout

\begin_layout Itemize
choke, unchoke, interested, not interested — 4 wiadomości informujące o
 zmianie stanu peera (związane z algorytmem z punktu 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:choking-alg"

\end_inset

), 
\end_layout

\begin_layout Itemize
have — wiadomość informująca o tym, że peer otrzymał nowy fragment, 
\end_layout

\begin_layout Itemize
request — żądanie fragmentu, 
\end_layout

\begin_layout Itemize
piece — wiadomość zawierająca fragment torrenta, 
\end_layout

\begin_layout Itemize
cancel — wiadomość anulująca żądanie fragmentu.
 
\end_layout

\begin_layout Subsection
Choking algorithm 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:choking-alg"

\end_inset


\end_layout

\begin_layout Standard
W idealnej sytuacji wymiana plików za pośrednictwem protokołu BitTorrent
 jest sprawiedliwa, to znaczy każdy peer może pobierać pliki, ale jednocześnie
 powinien udostępniać posiadane fragmenty innym.
 By zapobiec sytuacji, w której peer blokuje wysyłanie posiadanych fragmentów,
 wprowadzono odpowiedni algorytm.
 Wykorzystuje on 4 typy wiadomości spośród wspomnianych w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:jak-komunikuja"

\end_inset

.
 i polega na tym, że dany klient pozwala (unchoke) na pobieranie fragmentów
 od siebie tylko tym peerom, które posiadają i udostępnią klientowi swoje
 fragmenty.
 Pobieranie wymaga zatem kooperacji i wymiany interesujących, brakujących
 fragmentów.
 Bez tej wymiany połączenie zostaje przerwane (choke).
 
\end_layout

\begin_layout Subsection
Serwery potrzebne do działania protokołu
\end_layout

\begin_layout Standard
Protokół z założenia powinien być w pełni rozproszony i nie polegać na żadnych
 publicznych serwerach — jedynie na bezpośredniej komunikacji użytkowników
 końcowych (P2P).
 Niestety kilka usług serwerowych jest wciąż aktywnie wykorzystywanych do
 prawidłowego działania sieci:
\end_layout

\begin_layout Itemize
serwer hostujący metapliki .torrent lub magnet linki pozwalający na wyszukiwanie
 interesujących plików po nazwie, tagach, innych właściwościach, oferujący
 statystyki torrenta, komentarze itp.
 — może zostać zastąpiony wyszukiwarką torrentów wbudowaną w klienta, który
 wysyła zapytanie do podłączonych peerów, one przekazują je dalej, aż do
 momentu otrzymania odpowiedzi,
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO kademlia - wspomnieć że pozwala na wyszukiwanie zawartości w sieciach
 P2P bez potrzeby centralnego serwera, to jest oparte na DHT
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
tracker — istnieją jednak rozwiązania umożliwiające śledzenie swarmu bez
 użycia zewnętrznego serwera np.
 DHT, PEX (Peer Exchange),
\end_layout

\begin_layout Itemize
serwery pośredniczące w nawiązaniu połączenia dwóch klientów ukrytych w
 prywatnych sieciach IP (wykorzystujących translację adresów sieciowych).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO NAT - doczytać i może coś jeszcze dopisać
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zalety i wady protokołu
\end_layout

\begin_layout Standard
Wśród zalet protokołu znajduje się przede wszystkim wspomniane na początku
 zmniejszone obciążenie serwera.
 Prędkość pobierania może osiągnąć wyższą wartość niż limit transferu wychodzące
go z serwera — ograniczeniem jest jedynie dostępność pliku wśród peerów
 oraz limit transferu przychodzącego do danego klienta.
 Rozesłanie pliku o rozmiarze 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
m
\end_layout

\end_inset

 do 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
n
\end_layout

\end_inset

 odbiorców bez użycia protokołu wymagałoby transferu danych o rozmiarze
 
\begin_inset Formula $m\cdotp n$
\end_inset

 z węzła udostępniającego, natomiast z użyciem protokołu ilość danych wysłanych
 przez nadawcę mieści się w przedziale 
\begin_inset Formula $\left\langle m;m\cdotp n\right\rangle $
\end_inset

.
 Kolejną zaletą jest możliwość pobierania pliku nawet, jeśli oryginalny
 nadawca (twórca torrenta) jest niedostępny (zakładając oczywiście, że w
 swarmie rozesłane zostały najpierw wszystkie fragmenty pliku) — cecha ta
 okaże się przydatna podczas implementacji komunikatora grupowego.
 
\end_layout

\begin_layout Standard
Do wad protokołu należy zaliczyć zwiększone obciążenie oraz narzut komunikacyjny
 po stronie klienta — konieczność koordynacji pobierania i udostępniania,
 wysyłanie i odbieranie wiadomości kontrolnych.
 Wadą może być sam fakt, że klient zobowiązany jest do udostępniania pobieranego
 pliku.
 Jedną z ważniejszych kwestii, o jakie należy zadbać jest również dostępność
 pliku — klient nie pobierze całego torrenta jeśli nie znajdzie w sieci
 wszystkich jego fragmentów (tak zwany 
\begin_inset Quotes pld
\end_inset

problem ostatniego fragmentu
\begin_inset Quotes prd
\end_inset

).
 Dodatkowo problematyczne może być wyszukanie metapliku .torrent lub magnet
 linku odpowiadającego danemu torrentowi.
 
\end_layout

\begin_layout Section
WebTorrent 
\begin_inset CommandInset citation
LatexCommand cite
key "webtorrent"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:webtorrent"

\end_inset


\end_layout

\begin_layout Standard
WebTorrent to biblioteka napisana w języku JavaScript, implementująca protokół
 BitTorrent.
 Dzięki zastosowaniu tego języka możliwe jest użycie protokołu w skrypcie
 wykonywanym w przeglądarce po wejściu na stronę internetową.
 Biblioteki można również użyć jako moduł w programie dla platformy Node.js.
 Funkcjonalność oferowana w obu przypadkach jest niemal identyczna (poza
 kilkoma sytuacjami wynikającymi z ograniczeń danej platformy).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO 
\end_layout

\begin_layout Itemize
ograniczenia względem BT, czego WT nie implementuje a co robi inaczej (np
 UDP->WebRTC)
\end_layout

\begin_layout Itemize
webrtc DODATKOWY względem BitTorrent serwer potrzebny signalling (w przypadku
 WebTorrent jest nim tracker)
\end_layout

\begin_layout Itemize
stun, ICE, NAT traversal, 90% wszystkich połączeń to STUN (screen z wiresharka),
 ogromne liczby - to idzie w tysiące połączeń na minutę
\end_layout

\begin_deeper
\begin_layout Itemize
https://github.com/webtorrent/webtorrent/issues/145
\end_layout

\begin_layout Itemize
https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/
\end_layout

\begin_layout Itemize
https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-signaling — signaling
\end_layout

\begin_deeper
\begin_layout Itemize
ICE to protokół do przechodzenia przez firewalle
\end_layout

\begin_layout Itemize
A STUN server is used to get an external network address.
 
\end_layout

\begin_layout Itemize
TURN servers are used to relay traffic if direct (peer to peer) connection
 fails.
\end_layout

\end_deeper
\begin_layout Itemize
webrtc w webworkers niedostępne - https://github.com/w3c/webrtc-pc/issues/230
\end_layout

\begin_layout Itemize
webrtc wymaga też signalling server
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
Architektura
\end_layout

\begin_layout Standard
System komunikatora grupowego będący przedmiotem niniejszej pracy magisterskiej
 został oparty częściowo o architekturę klient-serwer, jednakże rola serwera
 została maksymalnie ograniczona, a częściowo o architekturę rozproszoną
 peer-to-peer (przy użyciu protokołu BitTorrent).
 W pierwszym typie architektury można wyróżnić 3 warstwy logiczne (3-layer
 architecture) — klienty, serwer oraz baza danych.
 Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architektura-komunikatora"

\end_inset

 przedstawia opisywaną architekturę.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/architektura.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architektura komunikatora 
\begin_inset CommandInset label
LatexCommand label
name "fig:Architektura-komunikatora"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Klient jest aplikacją webową typu Single Page Application.
 Oznacza to, że cały kod źródłowy oraz niezbędne widoki pobierane są z serwera
 (
\begin_inset Quotes pld
\end_inset

Serwer aplikacji
\begin_inset Quotes prd
\end_inset

 na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architektura-komunikatora"

\end_inset

) przy pierwszym połączeniu.
 
\end_layout

\begin_layout Standard
Oprócz wspomnianego serwera aplikacji umożliwiającego pobranie plików HTML,
 CSS oraz JS do działania programu niezbędny jest drugi serwer o architekturze
 REST.
 Umożliwia on rejestrację i autoryzację użytkowników oraz jest odpowiedzialny
 za tworzenie konwersacji i przydzielanie do nich odpowiednich użytkowników.
\end_layout

\begin_layout Standard
Serwer REST komunikuje się z trzecią warstwą — bazą danych.
 Baza danych typu dokumentowego (NoSQL) przechowuje niezbędne minimum informacji
 o użytkowniku, dzięki którym możliwe jest prowadzenie rozmów.
 
\end_layout

\begin_layout Standard
Kolejnym modułem jest wbudowana w klienta biblioteka WebTorrent do obsługi
 protokołu BitTorrent.
 Pozwala ona na bezpośrednią komunikację pomiędzy klientami.
 Wykorzystywana jest do przekazywania wiadomości.
 
\end_layout

\begin_layout Standard
Z specyfikacji biblioteki i protokołu wynika między innymi konieczność utrzymywa
nia dodatkowych serwerów — trackerów.
 Ze względu na fakt, że biblioteka jest oprogramowaniem open-source, istnieje
 możliwość samodzielnego uruchomienia tego typu serwera, jednak na potrzeby
 testów nie było to konieczne — istnieją w sieci publiczne trackery, z których
 można skorzystać.
\end_layout

\begin_layout Standard
Przedostatnim modułem koniecznym do prawidłowego działania komunikatora
 jest rozproszona tablica mieszająca (DHT) utrzymywana przez klienty, a
 używana do zapisywania i odczytywania info hasha najnowszej wysyłanej wiadomośc
i.
 Klient w momencie rozpoczęcia udostępniania wiadomości zapisuje jej info
 hash w DHT, a odbiorcy mogą go odczytać i rozpocząć pobieranie komunikatu.
 
\end_layout

\begin_layout Standard
Ostatnim elementem są publiczne serwery STUN (Session Traversal Utilities
 for NAT).
 Dzięki nim możliwe jest skomunikowanie ze sobą dwóch klientów znajdujących
 się w sieciach, których router stosuje translację adresów sieciowych.
 Takie serwery również istnieją w sieci więc ich implementacja i uruchomienie
 nie było konieczne.
 Za łączenie się z nimi odpowiedzialna jest biblioteka WebTorrent.
\end_layout

\begin_layout Section
Serwer REST i Baza Danych
\end_layout

\begin_layout Standard
Serwer został napisany w języku Python z użyciem biblioteki Eve 
\begin_inset CommandInset citation
LatexCommand cite
key "python-eve"

\end_inset

, która w łatwy sposób pozwala uruchomić serwer REST oferujący podstawowe
 operacje CRUD (Create, Read, Update, Delete) na obiektach.
 Biblioteka automatycznie generuje dla obiektów ścieżki dostępu REST z odpowiedn
imi metodami HTTP oraz zapisuje zmiany dokonywane na obiektach w podłączonej
 bazie danych.
 Wybór tej biblioteki wynika z faktu, że serwer REST w projekcie pełni niewielką
 rolę — wraz z bazą danych przechowuje jedynie te dane, które nie powinny
 zostać utracone, a mogłyby, gdyby były zapisane jedynie w przeglądarce
 użytkownika — wtedy użytkownik straciłby dostęp do swojego konta i informacji
 o przynależności do konwersacji.
 
\end_layout

\begin_layout Standard
Serwer przechowuje dane w nierelacyjnej (dokumentowej) bazie danych MongoDB.
 Struktura dokumentów w bazie odzwierciedla bezpośrednio schemat zaprojektowany
 w serwerze.
 
\end_layout

\begin_layout Standard
W kolejnych punktach przybliżono szczegóły obiektów 
\begin_inset Quotes pld
\end_inset

użytkownik
\begin_inset Quotes prd
\end_inset

 i 
\begin_inset Quotes pld
\end_inset

konwersacja
\begin_inset Quotes prd
\end_inset

 — ich atrybuty i metody REST.
 
\end_layout

\begin_layout Subsection
Użytkownicy i logowanie
\end_layout

\begin_layout Standard
Encja user posiada następujące atrybuty: 
\end_layout

\begin_layout Itemize
id (nadawany automatycznie), 
\end_layout

\begin_layout Itemize
username, 
\end_layout

\begin_layout Itemize
email, 
\end_layout

\begin_layout Itemize
password,
\end_layout

\begin_layout Itemize
salt.
 
\end_layout

\begin_layout Standard
W trakcie rejestracji serwer automatycznie uzupełnia pole salt, które wraz
 z przesłanym hasłem zostaje zapisane jako wynik funkcji skrótu kryptograficzneg
o BCrypt.
 Zapewnia to wyższy poziom bezpieczeństwa niż przechowywanie hasła w takiej
 postaci, w jakiej zostało ono przesłane przez użytkownika.
 Niezalogowany użytkownik ma dostęp jedynie do metody POST na kolekcji users
 (rejestracja nowego użytkownika) oraz metody login (POST) — zalogowanie
 się do systemu.
 Dopiero po zalogowaniu możliwe jest odczytanie szczegółów swojego profilu
 lub profilu innej osoby (metodą GET z podaniem odpowiedniego id).
 
\end_layout

\begin_layout Standard
W przypadku prawidłowego zalogowania serwer odsyła użytkownikowi szczegóły
 jego konta oraz dane poświadczające prawidłowe zalogowanie.
 Kontrola dostępu do ścieżek REST udostępnionych tylko dla zalogowanych
 użytkowników wykorzystuje najprostszy mechanizm autoryzacji — nagłówek
 HTTP Basic Authentication, który klient wypełnia danymi otrzymanymi od
 serwera podczas logowania.
\end_layout

\begin_layout Subsection
Konwersacje
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:Konwersacje"

\end_inset


\end_layout

\begin_layout Standard
Atrybuty encji conversations zostały wymienione poniżej: 
\end_layout

\begin_layout Itemize
id (nadawany automatycznie), 
\end_layout

\begin_layout Itemize
conversation_id (nazwa konwersacji; może być zdefiniowana przez użytkownika
 lub nadana losowo przez serwer), 
\end_layout

\begin_layout Itemize
user_id (id użytkownika),
\end_layout

\begin_layout Itemize
user_dht_id (klucz, pod którym użytkownik umieszcza info hash najnowszej
 wiadomości dla danej konwersacji w DHT).
\end_layout

\begin_layout Standard
Ścieżki REST dla obiektu konwersacje są dostępne dla zalogowanego użytkownika.
 Taka osoba ma kilka możliwości:
\end_layout

\begin_layout Itemize
stworzenie i automatyczne dołączenie do nowej konwersacji lub dołączenie
 do już istniejącej konwersacji (metoda POST), 
\end_layout

\begin_layout Itemize
pobranie informacji o użytkownikach, którzy uczestniczą w tej samej konwersacji
 co użytkownik, np.
 ich user_dht_id (metoda GET),
\end_layout

\begin_layout Itemize
wypisanie się z konwersacji (metoda DELETE).
\end_layout

\begin_layout Section
Klient i biblioteka WebTorrent
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
// TODO
\end_layout

\begin_layout Itemize
inne implementacyjne ciekawostki (zajrzeć do kodu)
\end_layout

\begin_layout Itemize
założenia - dostarczanie offline (może to być serwer imitujący użytkownika
 przyjaciel, jak w Tox), brak ograniczenia na liczbę użytkowników w ramach
 jednej konwersacji, czy konwersacje nie wpływają na siebie?
\end_layout

\begin_layout Itemize
p2p
\end_layout

\begin_layout Itemize
planktos - pobieranie strony jako torrent (odciążenie serwera aplikacji)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zaimplementowany w ramach projektu klient jest aplikacją webową typu Single
 Page Application.
 Do jej przygotowania wykorzystano framework AngularJS.
 Integralną częścią programu jest moduł do obsługi protokołu BitTorrent
 — biblioteka WebTorrent.
 Wygląd komunikatora przedstawiony został na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Wygląd-aplikacji-klienta"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/wiadomosci.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wygląd aplikacji klienta, ekran komunikatora
\begin_inset CommandInset label
LatexCommand label
name "fig:Wygląd-aplikacji-klienta"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Program klienta pozwala użytkownikowi na zalogowanie się do systemu komunikatora.
 Następnie użytkownik może dołączyć do konwersacji podając jej nazwę (conversati
on_id z punktu 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Konwersacje"

\end_inset

) lub utworzyć nową konwersację.
 Głównym celem programu jest prowadzenie rozmowy z innymi użytkownikami,
 którzy są zapisani do tej samej konwersacji — użytkownicy wysyłają i odbierają
 wiadomości.
 Kluczową cechą komunikatora jest sposób, w jaki instancje programu wymieniają
 się wiadomościami — nowo utworzona wiadomość wraz z pewnymi metadanymi
 jest traktowana jako plik i upubliczniana w sieci P2P w sposób opisany
 w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scenariusz utworzenia torrenta"

\end_inset

.
 Odbiór wiadomości przebiega według scenariusza opisanego w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scenariusz pobrania torrenta"

\end_inset

.
 W kolejnych punktach przybliżone zostaną szczegóły działania programu.
\end_layout

\begin_layout Subsection
Logowanie
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Ekran-logowania"

\end_inset

 zaprezentowano wygląd ekranu logowania.
 Formularz pozwala na podanie adresu email oraz hasła niezbędnych do zalogowania
 się do systemu komunikatora.
 Zatwierdzenie danych przyciskiem 
\begin_inset Quotes pld
\end_inset

Sign in
\begin_inset Quotes prd
\end_inset

 powoduje wysłanie ich do serwera REST, na którym przechodzą one weryfikację,
 czy dany użytkownik istnieje oraz czy podał prawidłowe hasło.
 W przypadku pomyślnego uwierzytelnienia, serwer odsyła szczegóły konta
 użytkownika i dane niezbędne do autoryzacji, a klient zapisuje je w pamięci
 przeglądarki (local storage).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/logowanie.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ekran logowania
\begin_inset CommandInset label
LatexCommand label
name "fig:Ekran-logowania"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inicjalizacja modułów
\end_layout

\begin_layout Standard
Poprawne zalogowanie do serwisu pozwala na przejście do głównego ekranu
 komunikatora (przedstawiony na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Wygląd-aplikacji-klienta"

\end_inset

).
 Po wyświetleniu tego widoku następuje pobranie z serwera REST niezbędnych
 informacji o konwersacji (jeśli użytkownik już w jakiejś uczestniczy),
 uruchomienie modułu torrent (wykorzystującego bibliotekę WebTorrent, odpowiedzi
alnego za wymianę wiadomości) oraz modułu, którego zadaniem jest przechowywanie
 posiadanych wiadomości i kontakt z bazą danych wbudowaną w przeglądarkę.
 Szczegółowo ten proces został omówiony poniżej.
\end_layout

\begin_layout Standard
Jeśli użytkownik był zapisany do konwersacji to klient pobiera z serwera
 REST szczegółowe informacje o tej konwersacji (atrybuty przedstawione w
 punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Konwersacje"

\end_inset

) oraz dane o innych uczestnikach tej konwersacji — między innymi ich identyfika
tor user_dht_id, który jest niezbędny w procesie odbierania wiadomości.
 Jeżeli użytkownik nie uczestniczył jeszcze w żadnej konwersacji to wyświetlone
 zostaje pole umożliwiające podanie jej nazwy (conversation_id) — rysunek
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Dołączanie-do-konwersacji"

\end_inset

.
 Szczegóły dołączania do konwersacji opisano w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:utw-dolacz-do-konwersacji"

\end_inset

.
\end_layout

\begin_layout Standard
Kolejnym krokiem jest uruchomienie modułu odpowiedzialnego za przechowywanie
 wiadomości (nazywany dalej modułem wiadomości).
 Moduł korzysta z bazy danych typu klucz-wartość znajdującej się w przeglądarce
 (IndexedDB) do 
\begin_inset Quotes pld
\end_inset

trwałego
\begin_inset Quotes prd
\end_inset

 zapisywania wysłanych i odebranych wiadomości.
 Słowo 
\begin_inset Quotes pld
\end_inset

trwałego
\begin_inset Quotes prd
\end_inset

 jest ujęte w cudzysłów, ponieważ użytkownik może w każdej chwili usunąć
 dane.
 Jedynym sposobem, by je w takiej sytuacji odzyskać jest pobranie ich od
 innego użytkownika.
 Podczas inicjalizacji moduł wczytuje do pamięci podręcznej wszystkie wiadomości
 znajdujące się w bazie danych — dzięki temu będą one dostępne dla modułu
 torrent.
\end_layout

\begin_layout Standard
Ostatni etap przygotowania aplikacji do pełnego działania wymaga uruchomienia
 modułu torrent obsługującego komunikację poprzez protokół BitTorrent.
 W ramach inicjalizacji moduł włącza klienta sieci torrent i rozpoczyna
 ponowne udostępnianie posiadanych wiadomości.
\end_layout

\begin_layout Subsection
Utworzenie lub dołączenie do konwersacji 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:utw-dolacz-do-konwersacji"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO 
\end_layout

\begin_layout Itemize
jaką strukturę tworzą peery (w jednej konwersacji, między konwersacjami)
 - to chyba zależy od biblioteki kogo z kim połączy, peery mogą tworzyć
 od łańcucha, przez ring po graf pełny
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W celu prowadzenia rozmowy z użytkownikami konieczne jest dołączenie do
 wspólnej konwersacji.
 Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Dołączanie-do-konwersacji"

\end_inset

 pokazuje formularz umożliwiający utworzenie nowej rozmowy lub podanie nazwy
 istniejącej.
 Użytkownik może rozpocząć nową konwersację i poczekać, aż inni do niej
 dołączą lub samemu dołączyć do już istniejącej.
 
\end_layout

\begin_layout Standard
W pierwszym przypadku użytkownik wybiera opcję 
\begin_inset Quotes pld
\end_inset

Create new
\begin_inset Quotes prd
\end_inset

.
 Aplikacja wysyła do serwera REST żądanie stworzenia konwersacji o losowej
 nazwie.
 Serwer automatycznie dołącza użytkownika do nowej konwersacji i odpowiada
 odsyłając nazwę konwersacji (conversation_id).
 Użytkownik zobaczy tę nazwę w polu 
\begin_inset Quotes pld
\end_inset

conversation ID
\begin_inset Quotes prd
\end_inset

.
 Zadaniem użytkownika jest teraz rozesłanie nazwy konwersacji do osób, z
 którymi chce prowadzić rozmowę.
 Może to zrobić, podobnie jak w przypadku komunikatora Darkwire (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Darkwire"

\end_inset

), na przykład za pośrednictwem email, SMS lub przekazać osobiście.
\end_layout

\begin_layout Standard
Drugi przypadek zakłada, że użytkownik otrzymał od kogoś nazwę konwersacji
 — wpisuje ją w pole 
\begin_inset Quotes pld
\end_inset

conversation ID
\begin_inset Quotes prd
\end_inset

 i zatwierdza przyciskiem 
\begin_inset Quotes pld
\end_inset

Join
\begin_inset Quotes prd
\end_inset

.
 Klient wysyła do serwera REST żądanie, a serwer zapisuje w bazie danych
 fakt dołączenia użytkownika do konwersacji.
 Serwer w odpowiedzi informuje klienta o pomyślnym zakończeniu procedury.
 
\end_layout

\begin_layout Standard
Dodatkowym założeniem, które należy spełnić w obu przypadkach przed dołączeniem
 do konwersacji jest posiadanie przez użytkownika unikalnego user_dht_id
 (atrybut z punktu 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Konwersacje"

\end_inset

).
 Jest to klucz w DHT, pod którym użytkownik umieszcza informację o najnowszej
 wysłanej przez siebie wiadomości (jej info hash).
 Wartość user_dht_id powinna być unikalna.
 Należy ją przesłać razem z żądaniem opisanym w powyższych przypadkach.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/dolacz.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Dołączanie do konwersacji
\begin_inset CommandInset label
LatexCommand label
name "fig:Dołączanie-do-konwersacji"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Struktura komunikatu
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:Struktura komunikatu"

\end_inset


\end_layout

\begin_layout Standard
Wiadomość przesyłana między uczestnikami rozmowy ma następującą strukturę:
\end_layout

\begin_layout Itemize
content (treść wiadomości),
\end_layout

\begin_layout Itemize
type (typ wiadomości, tekst, plik lub kontrolna),
\end_layout

\begin_layout Itemize
timestamp (znacznik czasu nadania wiadomości),
\end_layout

\begin_layout Itemize
sender (nadawca wiadomości),
\end_layout

\begin_layout Itemize
previousInfoHash (wartość info hash poprzedniej wiadomości).
\end_layout

\begin_layout Standard
Z własności protokołu BitTorrent wynika, że torrenty są niemodyfikowalne
 (immutable) — zawartość plików lub ich liczba nie może ulec zmianie bez
 zmiany wartości info hash.
 Konieczne zatem było przyjęcie założenia, że każda nowa wiadomość wysłana
 przez użytkownika staje się nowym torrentem.
 Scenariusz, w którym użytkownik dodaje wiadomość jako kolejny plik do istniejąc
ego torrenta jest na chwilę obecną niemożliwy do zrealizowania, chociaż
 istnieją próby wdrożenia takiej możliwości (w protokole BitTorrent 
\begin_inset CommandInset citation
LatexCommand cite
key "bep46-bt"

\end_inset

 oraz w bibliotece WebTorrent 
\begin_inset CommandInset citation
LatexCommand cite
key "bep46-wt"

\end_inset

).
 Niemniej jednak zdecydowano o zachowaniu przyjętego założenia.
 
\end_layout

\begin_layout Standard
Zastosowanie znaczników czasowych pozwala na zdefiniowanie kolejności wiadomości
 — ich odbiorcy będą w stanie posortować odbierane komunikaty zgodnie z
 porządkiem FIFO.
 Znaczniki dodatkowo gwarantują globalne uporządkowanie wiadomości (total
 order) — jeśli wszyscy użytkownicy w ramach konwersacji odbiorą wszystkie
 wiadomości (każdy będzie posiadał identyczny zbiór), to zobaczą je w takiej
 samej kolejności.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\begin_layout Plain Layout
czy na pewno jest total order lub fifo jeśli wyswietlimy najpierw nowszą
 wiadomośc, a potem starszą? (brak czekania na odebranie pprzednich wiadomości)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Użycie znaczników nie gwarantuje jednak przyczynowego uporządkowania (causal
 order), ponieważ zegary na maszynach użytkowników nie są zsynchronizowane.
 W większości przypadków 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
niewielka
\end_layout

\end_inset

 różnica czasu pozwoli na zachowanie uporządkowania przyczynowego.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
Niewielka
\end_layout

\end_inset

 różnica czasu 
\begin_inset Formula $\Delta t$
\end_inset

 pomiędzy zegarami na maszynach dwóch użytkowników 
\begin_inset Formula $U_{N}$
\end_inset

 (użytkownik-nadawca) i 
\begin_inset Formula $U_{O}$
\end_inset

 (użytkownik-odbiorca) oznacza, że 
\begin_inset Formula $\Delta t<min(t)+t_{0}$
\end_inset

, gdzie:
\end_layout

\begin_layout Itemize
\begin_inset Formula $min(t)$
\end_inset

 to minimalny czas, który upłynie od momentu nadania wiadomości 
\begin_inset Formula $m$
\end_inset

 przez 
\begin_inset Formula $U_{N}$
\end_inset

 (ustawienia czasu nadania w polu timestamp) do momentu odebrania wiadomości
 
\begin_inset Formula $m$
\end_inset

 przez 
\begin_inset Formula $U_{O}$
\end_inset

 (wyświetlenia wiadomości 
\begin_inset Formula $m$
\end_inset

 u odbiorcy), 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{0}$
\end_inset

 to czas potrzebny na napisanie i nadanie odpowiedzi zależnej przyczynowo
 od wiadomości 
\begin_inset Formula $m$
\end_inset

 przez 
\begin_inset Formula $U_{O}$
\end_inset

, przy czym w ogólności może on wynosić 0 (zero).
\end_layout

\begin_layout Standard
Możliwy jest jednak następujący scenariusz:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Delta t>min(t)$
\end_inset

, 
\begin_inset Formula $t_{0}=0$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $T_{N}>T_{O}$
\end_inset

, gdzie 
\begin_inset Formula $T_{N}$
\end_inset

 i 
\begin_inset Formula $T_{O}$
\end_inset

 to stan zegara maszyny nadawcy/odbiorcy w danym momencie, a nierówność
 oznacza, że gdyby porównać w tym samym momencie zegary obu maszyn, to zegar
 maszyny nadawcy będzie wskazywał wyższą wartość.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $U_{N}$
\end_inset

 wysyła wiadomość 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $U_{O}$
\end_inset

 odbiera wiadomość 
\begin_inset Formula $m$
\end_inset

 i od razu na nią odpowiada (
\begin_inset Formula $t_{0}=0$
\end_inset

), wysyłając wiadomość 
\begin_inset Formula $n$
\end_inset

.
 Timestamp ustawiony w odpowiedzi 
\begin_inset Formula $n$
\end_inset

 będzie miał niższą wartość niż timestamp otrzymany w wiadomości 
\begin_inset Formula $m$
\end_inset

.
 Zarówno 
\begin_inset Formula $U_{N}$
\end_inset

 jak i 
\begin_inset Formula $U_{O}$
\end_inset

 zaobserwują ten fakt — wiadomość 
\begin_inset Formula $n$
\end_inset

 zostanie wyświetlona powyżej wiadomości 
\begin_inset Formula $m$
\end_inset

 (co oznacza, że została wysłana wcześniej).
 
\end_layout

\begin_layout Subsection
Wysłanie wiadomości
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO 
\end_layout

\begin_layout Itemize
scenariusz z przekazywaniem offline (nadawca niedostępny, przekazuje inna
 osoba w konwersacji lub serwer pośrednik) ktoś musi być dostępny żeby nam
 przekazać starsze komunikaty
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aby wysłać wiadomość użytkownik podaje jej treść w polu 
\begin_inset Quotes pld
\end_inset

Type message
\begin_inset Quotes prd
\end_inset

 i zatwierdza przyciskiem 
\begin_inset Quotes pld
\end_inset

Send
\begin_inset Quotes prd
\end_inset

.
 Dalsze czynności wykonuje moduł torrent.
 Najpierw tworzy strukturę wiadomości (szerzej opisaną w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Struktura komunikatu"

\end_inset

).
 Następnie rozpoczyna udostępnianie komunikatu w sieci P2P zgodnie z opisem
 z punktu 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scenariusz utworzenia torrenta"

\end_inset

 (jest to zadanie biblioteki WebTorrent).
 Kolejnym krokiem jest zapamiętanie info hasha udostępnionej wiadomości.
 Klient zapisuje komunikat za pośrednictwem modułu wiadomości w bazie danych
 IndexedDB — kluczem jest info hash, a wartością struktura wiadomości.
 
\end_layout

\begin_layout Standard
W trakcie implementowania programu zaobserwowano, że wraz ze wzrostem liczby
 wiadomości traktowanie jednej wiadomości jako jeden torrent bardzo szybko
 prowadzi do nadmiernego zużywania zasobów, a nawet do błędnego zakończenia
 programu.
 Z tego powodu zdecydowano o zaprojektowaniu i wdrożeniu algorytmu zmniejszające
go liczbę jednocześnie udostępnianych torrentów.
 W ogólności polega on na okresowym zastępowaniu torrentów zawierających
 pojedynczą wiadomość (poziom 0) jednym torrentem (nazywanym dalej torrentem
 kontrolnym), który składa się z wielu wiadomości (poziom 1).
 Algorytm wykonuje się rekurencyjnie — jeśli powstanie zbyt dużo torrentów
 kontrolnych na poziomie 1 to zostaną one połączone w jeden torrent kontrolny
 na poziomie 2, itd.
 Algorytm uruchamiany jest jako kolejny krok po zleceniu zapisu do bazy
 danych.
 Został opisany szczegółowo poniżej:
\end_layout

\begin_layout Enumerate
Jeżeli na danym poziomie znajduje się zbyt dużo wiadomości (więcej niż zadany
 próg) to rozpocznij procedurę zamieniania wielu torrentów w jeden torrent
 kontrolny.
 W przeciwnym przypadku zakończ algorytm.
\end_layout

\begin_layout Enumerate
Stwórz listę wiadomości, które znajdą się w nowym torrencie kontrolnym.
\end_layout

\begin_layout Enumerate
Stwórz listę info hashy, które posiadają wiadomości znajdujące się na liście
 w punkcie 2.
 Dodatkowo, jeśli torrent kontrolny będzie zastępował inne torrenty kontrolne,
 stwórz listę info hashy zastępowanych torrentów kontrolnych.
\end_layout

\begin_layout Enumerate
Stwórz strukturę wiadomości (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Struktura komunikatu"

\end_inset

), w polu 
\begin_inset Quotes pld
\end_inset

treść
\begin_inset Quotes prd
\end_inset

 umieść listy z punktu 3.
\end_layout

\begin_layout Enumerate
Usuń z klienta sieci P2P torrenty o info hashach znajdujących się na listach
 z punktu 3.
\end_layout

\begin_layout Enumerate
Rozpocznij udostępnianie pliku składającego się z wszystkich wiadomości
 z punktu 2 oraz wiadomości z punktu 4 — procedura identyczna jak wysyłanie
 zwykłej wiadomości.
 W bazie danych zapisywana jest wiadomość z punktu 4 oraz usuwane z niej
 są te zastąpione.
 
\end_layout

\begin_layout Enumerate
Jeśli stworzenie nowego torrenta kontrolnego spowodowało, że na jego poziomie
 znalazło się zbyt wiele torrentów, wykonaj algorytm dla tego poziomu.
\end_layout

\begin_layout Standard
Po zakończeniu algorytmu należy wykonać ostatni krok, którym jest umieszczenie
 wartości najnowszego info hasha w DHT pod kluczem user_dht_id.
 Działanie DHT zostało szczegółowo opisane w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:DHT"

\end_inset

.
 
\end_layout

\begin_layout Standard
Dla poprawnego działania programu kluczowe jest, by kolejna nowa wiadomość
 przeszła procedurę wysyłania dopiero po zakończeniu procedury wysyłania
 poprzedniej wiadomości.
 Wynika to z konieczności podania wartości poprzedniego info hasha w strukturze
 wiadomości.
 
\end_layout

\begin_layout Subsection
Odebranie wiadomości
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:Odebranie_wiadomości"

\end_inset


\end_layout

\begin_layout Standard
Procedura odebrania wiadomości rozpoczyna się okresowym sprawdzeniem najnowszej
 wartości info hash w DHT dla kluczy user_dht_id poszczególnych uczestników
 rozmowy.
 Moduł torrent sprawdza, czy torrenty o tych info hashach znajdują się na
 liście pobieranych torrentów lub czy zostały już pobrane i znajdują się
 na liście wiadomości w module wiadomości.
 Jeśli żaden z powyższych warunków nie jest spełniony, wtedy na podstawie
 wartości info hash tworzony jest magnet link i rozpoczyna się procedura
 pobrania torrenta (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scenariusz pobrania torrenta"

\end_inset

).
 Biblioteka WebTorrent pozwala na zarządzanie plikami w trakcie ich pobierania
 — możliwe jest odczytanie zawartości wiadomości pobranych w całości, podczas
 gdy pozostałe pliki są dalej przesyłane.
 Odczytana wiadomość zostaje zapisana za pośrednictwem modułu wiadomości
 w bazie danych oraz na liście wiadomości do wyświetlenia użytkownikowi.
 Oprócz tego moduł torrent sprawdza, czy poprzednia wiadomość wysłana przez
 nadawcę znajduje się na liście wiadomości lub liście pobieranych torrentów.
 Jeśli nie — moduł rozpoczyna procedurę pobierania tej wiadomości.
\end_layout

\begin_layout Standard
W sytuacji, gdy pobierany torrent był torrentem kontrolnym, moduł torrent
 usuwa z klienta sieci P2P torrenty, które torrent kontrolny zastępuje.
 Moduł zapisuje również w bazie danych brakujące wiadomości, o ile istnieje
 taka konieczność.
 Podobnie jak w przypadku zwykłego torrenta, jeśli brakuje poprzedniej wiadomośc
i, moduł zacznie jej pobieranie.
 
\end_layout

\begin_layout Section
DHT
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:DHT"

\end_inset


\end_layout

\begin_layout Standard
Moduł DHT czyli rozproszona tablica mieszająca jest systemem składającym
 się z wielu węzłów pozwalającym na przechowywanie informacji.
 Węzłem staje się każdy klient systemu komunikatora.
 Węzły dzielą między sobą pewien zbiór kluczy i posiadają możliwość komunikowani
a się z innymi węzłami i przesyłania im posiadanych informacji.
 Zadaniem węzła jest przechowywanie informacji dotyczących przypisanego
 mu podzbioru kluczy.
 Każda informacja zapisywana w DHT posiada etykietę (w przypadku systemu
 komunikatora jest nią user_dht_id), która następnie zamieniana jest na
 klucz przez funkcję haszującą.
 Informacją w systemie komunikatora jest info hash najnowszej wysłanej przez
 klienta wiadomości.
 
\end_layout

\begin_layout Standard
Przed przystąpieniem do pracy nad projektem zakładano, że biblioteka WebTorrent
 jest wyposażona w mechanizm opisany powyżej.
 Jest to częściowo prawda — wersja biblioteki dla programów na platformę
 Node.js posiada taką możliwość.
 Niestety brakuje jej w wersji dla przeglądarek.
 Powody dla braku wsparcia DHT w bibliotece WebTorrent w przeglądarce są
 następujące:
\end_layout

\begin_layout Itemize
Przeglądarki mogą komunikować się bezpośrednio ze sobą jedynie dzięki protokołow
i WebRTC.
 Funkcjonuje on poprawnie dla niewielkiej liczby jednoczesnych połączeń,
 jednak na potrzeby zaimplementowania DHT konieczne byłoby utrzymywanie
 większej liczby równoległych połączeń, co może prowadzić do szybkiego wyczerpan
ia zasobów przeglądarki.
\end_layout

\begin_layout Itemize
Jednym ze sposobów zaimplementowania DHT dla biblioteki WebTorrent jest
 zaadaptowanie algorytmu Kademlia działającego już dla protokołu BitTorrent.
 Wymaga on jednak zapamiętywania listy węzłów, z którymi dany węzeł nawiązał
 dotychczas połączenie, a to oznacza, że połączenia WebRTC muszą pozostać
 otwarte (nie można ich zakończyć).
 Jest to o wiele bardziej kosztowne w przypadku WebRTC niż w oryginalnej
 implementacji, która korzysta z bezpołączeniowego protokołu komunikacji
 UDP.
\end_layout

\begin_layout Itemize
Kolejnym, bardzo istotnym problemem jest brak wsparcia protokołu WebRTC
 dla dedykowanych wątków roboczych (WebWorker, ServiceWorker, itp.).
 Bez tego wsparcia kod pozwalający na obsługę DHT musi być wykonywany w
 głównym wątku danej strony internetowej, a to może doprowadzić nawet do
 całkowitego zablokowania interfejsu.
 W chwili obecnej trwają próby wprowadzenia wsparcia protokołu dla wątków
 roboczych — być może w przyszłości ten problem zostanie rozwiązany.
 
\end_layout

\begin_layout Standard
W zaistniałej sytuacji przeprowadzono poszukiwania alternatywnej biblioteki
 udostępniającej mechanizm DHT dla przeglądarek.
 Znalezione biblioteki pozwalały programiście na zdefiniowanie kanału wymiany
 informacji pomiędzy węzłami 
\begin_inset CommandInset citation
LatexCommand cite
key "kademlia-dht"

\end_inset

 lub posiadały działający mechanizm 
\begin_inset CommandInset citation
LatexCommand cite
key "kadtools"

\end_inset

.
 Jednakże w trakcie wstępnych testów okazało się, że żadna biblioteka nie
 zapewnia satysfakcjonujących rezultatów — informacje były przesyłane zbyt
 długo lub w ogóle nie docierały do niektórych węzłów.
 
\end_layout

\begin_layout Standard
Ze względu na brak zaimplementowanego mechanizmu DHT w bibliotece WebTorrent
 oraz niesatysfakcjonujące alternatywy zdecydowano o zastąpieniu tego mechanizmu
 atrapą (mock).
 Funkcjonalność tego rozwiązania pozostaje niezmienna — każdy klient ma
 możliwość zapisania najnowszej wartości info hash pod określonym kluczem
 (user_dht_id) oraz odczytania tej informacji.
 Zmianie uległ sposób przechowywania informacji — zadanie to nie należy
 już do sieci powiązanych ze sobą klientów, a stało się jednym z zadań serwera
 REST.
 Serwer udostępnia ścieżkę REST /dht, która umożliwia następujące akcje:
\end_layout

\begin_layout Itemize
metoda HTTP GET z parametrem user_dht_id pozwala na pobranie wartości przechowyw
anej dla klucza user_dht_id,
\end_layout

\begin_layout Itemize
metoda POST pozwala na zapisanie wartości dla klucza user_dht_id.
\end_layout

\begin_layout Section
Bezpieczeństwo, kryptografia, JavaScript
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Bezpieczeństwo, krypto, JS"

\end_inset


\end_layout

\begin_layout Standard
Mobilne i dektopowe klienty aplikacji Bleep (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:bleep"

\end_inset

) oraz aplikacji Signal (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:signal"

\end_inset

) oferują szyfrowanie wiadomości.
 Webowy klient aplikacji Darkwire (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Darkwire"

\end_inset

) również.
 W ramach niniejszej pracy magisterskiej zbadano sposób implementacji tego
 mechanizmu w przytoczonych aplikacjach oraz podjęto próbę zaprojektowania
 go dla systemu komunikatora.
 
\end_layout

\begin_layout Standard
Poufność wiadomości w systemie komunikatora jest konieczna, ponieważ każdy
 użytkownik systemu (ale też osoba spoza niego) ma możliwość pobrania i
 odczytania treści wiadomości przesyłanych jako torrenty.
 Gdyby wiadomość była zaszyfrowana, posiadanie jej w takiej formie nie powoduje
 negatywnych skutków.
 Głównym problemem do rozwiązania jest przechowywanie kluczy pozwalających
 na odczytanie zaszyfrowanych wiadomości i podpisywanie wysyłanych treści.
 Problem przechowywania dotyczy zarówno zarządzania kluczami w trakcie pracy
 aplikacji jak i po jej zamknięciu — zapisanie kluczy w pamięci trwałej.
 Klucz prywatny nie powinien być wysyłany poza urządzenie, na którym został
 wygenerowany.
 
\end_layout

\begin_layout Standard
Ostatecznie zrezygnowano z wdrożenia szyfrowania wiadomości, choć technicznie
 jest to osiągalne, ponieważ mechanizm ten posiadałby istotne wady mogące
 powodować brak gwarancji poufności przesyłanych danych.
 Podsumowanie badań opisano w poniższych punktach.
\end_layout

\begin_layout Subsection
Darkwire
\end_layout

\begin_layout Standard
Aplikacja webowa Darkwire automatycznie szyfruje wiadomości w przeglądarce
 użytkownika przed wysłaniem ich do serwera.
 Serwer przesyła wiadomość do odbiorców.
 Po dotarciu do nich, treść jest odszyfrowywana.
 W programie zastosowano kryptografię klucza publicznego do stworzenia klucza
 symetrycznego danej wiadomości.
 Aplikacja korzysta z web cryptography API 
\begin_inset CommandInset citation
LatexCommand cite
key "web cryptography api"

\end_inset

 do zarządzania kluczami kryptograficznymi.
 
\end_layout

\begin_layout Standard
Scenariusz uruchomienia programu i przesłania zaszyfrowanej wiadomości jest
 następujący 
\begin_inset CommandInset citation
LatexCommand cite
key "darkwire szyfrowanie how it works"

\end_inset

:
\end_layout

\begin_layout Enumerate
Podczas uruchomienia, program tworzy nową rozmowę (chat room) oraz parę
 kluczy (publiczny i prywatny).
 
\end_layout

\begin_layout Enumerate
W momencie dołączenia nowej osoby do rozmowy, aplikacje użytkowników wymieniają
 się kluczami publicznymi uczestników rozmowy.
 
\end_layout

\begin_layout Enumerate
W celu wysłania wiadomości program najpierw generuje 3 nowe klucze: symetryczny
 klucz sesji, klucz podpisujący (umożliwiający weryfikację sygnatury wiadomości)
 oraz wektor inicjujący (initialization vector).
 
\end_layout

\begin_layout Enumerate
Treść wiadomości zostaje zaszyfrowana przy pomocy klucza sesji i wektora
 inicjującego.
 Oprócz tego tworzona jest sygnatura wiadomości przy użyciu klucza podpisującego.
 
\end_layout

\begin_layout Enumerate
Klucz sesji i klucz podpisujący zostają zaszyfrowane kluczami publicznymi
 odbiorców, dla każdego z osobna — ta technika pozwala na uniknięcie szyfrowania
 całej treści wiadomości osobno dla wszystkich odbiorców.
 
\end_layout

\begin_layout Enumerate
Ostatnim krokiem przed wysłaniem wiadomości jest przygotowanie paczki danych
 do wysłania — składa się ona z zaszyfrowanej wiadomości, wektora inicjującego,
 sygnatury wiadomości, zaszyfrowanego klucza sesji oraz zaszyfrowanego klucza
 podpisującego.
 
\end_layout

\begin_layout Enumerate
Odbiorca, po otrzymaniu takiej paczki danych, odszyfrowuje swoim kluczem
 prywatnym klucze sesji i podpisujący.
 Używając odszyfrowanego klucza sesji i wektora inicjującego odbiorca odszyfrowu
je treść wiadomości i może zweryfikować sygnaturę wiadomości odszyfrowanym
 kluczem podpisującym.
 
\end_layout

\begin_layout Standard
Przedstawiony scenariusz gwarantuje poufność wiadomości i autentyczność
 odbiorcy podczas normalnej pracy aplikacji.
 Istnieją jednak wektory ataku pozwalające na zdobycie kluczy prywatnych
 i w konsekwencji na odczytanie przesłanych wiadomości czy przejęcie kontroli
 nad kontem użytkownika i podszywanie się pod nadawcę.
 Głównym problemem z punktu widzenia bezpieczeństwa jest przechowywanie
 klucza prywatnego jako wartość zmiennej w skrypcie JavaScript (lub w niezabezpi
eczony sposób w local storage czy IndexedDB).
 Wykorzystując choćby atak XSS (Cross-site scripting), czyli uruchomienie
 własnego skryptu osadzonego w treści atakowanej strony, można pozyskać
 wrażliwe dane.
 Zmiany w kodzie strony może dokonać nie tylko cracker, ale również twórca
 oprogramowania z własnej woli lub zmuszony przez trzecią stronę (np.
 agencję rządową).
 
\end_layout

\begin_layout Standard
Użycie powyższej metody do przechowywania wrażliwych danych może prowadzić
 do ich kradzieży i ujawnienia treści wiadomości.
 Jako usprawiedliwienie można podać przykład Messengera (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:messenger"

\end_inset

), który nie stosuje w ogóle szyfrowania wiadomości — jedynym zabezpieczeniem
 jest przesyłanie ich do serwera szyfrowanymi kanałami.
 W bazie danych są one zapisywane w takiej samej formie, w jakiej zostały
 wprowadzone przez użytkownika.
 Zdobycie dostępu do bazy danych przez osoby niepowołane spowoduje ujawnienie
 treści wiadomości.
 Niemniej jednak, taki wektor ataku wydaje się być mniej prawdopodobny —
 bazy danych są zazwyczaj lepiej zabezpieczone niż komputery użytkowników
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO jakieś źródło czy potwierdzenie? Bardziej formalnie?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W aplikacjach webowych istnieje jeszcze inna możliwość przesyłania i przechowywa
nia poufnych informacji (np.
 tokenów uwierzytelniających), a mianowicie ciasteczka (cookies).
 Te małe fragmenty tekstu są wysyłane przez serwer do klienta w nagłówku
 HTTP, a przeglądarka odsyła je wraz z kolejnymi żądaniami.
 W celu zabezpieczenia tych informacji stosuje się szyfrowany protokół (np.
 HTTPS) oraz ustawia niezbędne flagi (jak choćby httpOnly, secure, domain,
 path itd.).
 Ustawienie pierwszej flagi skutkuje brakiem dostępu do zawartości ciasteczka
 z poziomu kodu JavaScript.
 Niestety w systemie komunikatora ten sposób przechowywania poufnych informacji
 nie może być wykorzystany, gdyż większość operacji wykonywanych jest z
 poziomu skryptu, a komunikaty przesyłane są innymi protokołami niż HTTP.
 
\end_layout

\begin_layout Subsection
Bleep i Signal
\end_layout

\begin_layout Standard
Natywne aplikacje mobilne mają nad aplikacjami webowymi istotną przewagę
 — umożliwiają programistom dostęp do pamięci trwałej urządzenia.
 Dodatkowo, systemy mobilne zwiększają bezpieczeństwo przechowywanych informacji
 poprzez izolację danych zapisywanych przez konkretną aplikację — inne programy
 nie mają dostępu do tych obszarów.
 Ta możliwość pozwala na znacznie bezpieczniejsze przechowywanie poufnych
 danych.
 Wszelkie operacje związane z szyfrowaniem odbywają się na urządzeniach
 użytkowników.
\end_layout

\begin_layout Standard
Oprócz tego, twórcy przytoczonych aplikacji zastosowali znacznie bardziej
 rozbudowany mechanizm przesyłania wiadomości niż w przypadku aplikacji
 Darkwire.
 W aplikacji Signal wprowadzono choćby 
\begin_inset Quotes pld
\end_inset

The Double Ratchet Algorithm
\begin_inset Quotes prd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "signal double ratchet"

\end_inset

 — algorytm gwarantujący własność utajnienia przekazywania (forward secrecy).
 Każda wiadomość jest szyfrowana innym kluczem.
 Ponadto, nawet jeśli cracker uzyskałby dostęp do pojedynczej wiadomości
 i jej metadanych, nie może na ich podstawie obliczyć wartości poprzednich
 ani przyszłych kluczy.
 Podobny mechanizm oferuje aplikacja Bleep 
\begin_inset CommandInset citation
LatexCommand cite
key "bleep forward secrecy"

\end_inset

.
 
\end_layout

\begin_layout Standard
Twórcy aplikacji Bleep umożliwiają użytkownikom wysyłanie wiadomości pod
 nieobecność odbiorcy — zapisywana jest ona wtedy w DHT.
 Węzłami w DHT są aplikacje użytkowników, więc dane przechowywane w DHT
 również muszą być zaszyfrowane 
\begin_inset CommandInset citation
LatexCommand cite
key "bleep forward secrecy offline"

\end_inset

.
 Algorytm jest podobny do przedstawionego powyżej z niewielką zmianą — nowy
 klucz generowany jest nie dla każdej wiadomości, a dla paczki wiadomości
 nadanych podczas nieobecności odbiorcy.
 Gdy odbiorca staje się dostępny, odczytuje wiadomości i generuje nowy klucz.
 
\end_layout

\begin_layout Subsection
Inne pomysły i wnioski
\end_layout

\begin_layout Standard
Badanie rozwiązań wdrożonych w powyższych aplikacjach doprowadziło do powstania
 innych koncepcji rozwoju systemu komunikatora prowadzących do zabezpieczenia
 konwersacji między użytkownikami.
 Przedstawione zostały poniżej.
\end_layout

\begin_layout Itemize
Przechowywanie kluczy publicznych i prywatnych w bazie danych z dostępem
 poprzez serwer REST.
 Klucze mogą być generowane przez serwer lub przez klienta.
 Rozwiązanie nie jest poprawne jeśli zakłada się, że nikt poza nadawcą i
 odbiorcami nie ma prawa odczytać treści wiadomości.
 Jeśli jednak założenie to zostanie złagodzone i oprócz wspomnianych osób
 dostęp do treści wiadomości będzie miał zaufany serwer, rozwiązanie mogłoby
 zostać wprowadzone.
 W tej sytuacji uzyskuje się skalę poufności podobną do aplikacji Messenger
 (punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:messenger"

\end_inset

), w przypadku której wiadomości również mogą być odczytane z bazy danych.
 
\end_layout

\begin_layout Itemize
Rozwinięciem poprzedniego rozwiązania byłoby wygenerowanie pary kluczy po
 stronie klienta oraz dodatkowe zabezpieczenie ich w taki sposób, by jedynie
 użytkownik miał możliwość ich odczytania po podaniu hasła dostępu.
 Następnie, bezpieczne dane są wysyłane do serwera i tam przechowywane.
 Na żądanie klienta, na przykład podczas uruchamiania aplikacji, dane są
 pobierane, użytkownik podaje hasło i uzyskuje dostęp do poufnych informacji.
 Niestety, oba rozwiązania są w dalszym ciągu podatne na kradzież danych
 — odszyfrowane klucze są przetwarzane przez skrypt i mogą zostać przechwycone.
\end_layout

\begin_layout Itemize
Ostatnim, póki co koncepcyjnym, pomysłem jest zastosowanie Web Cryptography
 API 
\begin_inset CommandInset citation
LatexCommand cite
key "webCrypto API w3,webCrypto experimental "

\end_inset

.
 Konieczne jest jednak założenie, że nie będzie istniała możliwość odczytania
 czy importu kluczy prywatnych z poziomu kodu JavaScript.
 Wszelkie operacje na poufnych danych (generowanie kluczy, szyfrowanie i
 odszyfrowywanie danych) powinny być wykonywane przez algorytmy zaimplementowane
 bezpośrednio w przeglądarce — dzięki temu unika się przechowywania kluczy
 prywatnych w zmiennych i ich przetwarzania przez kod JavaScript, a to z
 kolei uniemożliwia ich kradzież.
 Algorytmy dostępne byłyby przez API.
 
\end_layout

\begin_layout Section
Dalszy rozwój
\end_layout

\begin_layout Standard
Poniżej opisano pokrótce kilka idei rozwijających system komunikatora.
\end_layout

\begin_layout Itemize
Zaimplementowanie relacji znajomości pomiędzy użytkownikami.
 Dzięki temu osoba tworząca konwersację będzie mogła od razu dopisać do
 niej uczestników wybierając ich z listy swoich znajomych.
 Kwestią do rozstrzygnięcia pozostaje w tej sytuacji wybranie, kto ma przypisać
 uczestnikom wartość user_dht_id (osoba tworząca konwersację czy każdy jej
 członek z osobna).
\end_layout

\begin_layout Itemize
Zagwarantowanie spójności przyczynowej wiadomości i wyświetlanie komunikatów
 dopiero, gdy pobrane zostały wszystkie poprzednie.
 Obie własności spowodują bardziej realistyczne wrażenie prowadzenia rozmowy.
 Jeśli użytkownik wysłał wiadomość 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
b
\end_layout

\end_inset

 w odpowiedzi na otrzymaną wiadomość 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
a
\end_layout

\end_inset

 to pojawią się one w oknie rozmowy w odpowiedniej kolejności — najpierw
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
a
\end_layout

\end_inset

, potem 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
b
\end_layout

\end_inset

.
 Jest to możliwe do osiągnięcia, jeśli wiadomości będą zawierały zegar wektorowy
 z wartościami ostatnio odebranych wiadomości.
\end_layout

\begin_layout Itemize
Szyfrowanie wiadomości.
 Sposoby implementacji oraz ich znane wady opisano w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Bezpieczeństwo, krypto, JS"

\end_inset

.
 Niemniej jednak ta własność jest niezbędna, by treść wiadomości nie mogła
 zostać odczytana przez osoby niepowołane (użytkowników nie należących do
 danej konwersacji).
 
\end_layout

\begin_layout Itemize
Zagwarantowanie dostarczenia wiadomości w sytuacji, gdy użytkownik uruchamia
 aplikację i żaden z uczestników konwersacji nie jest dostępny.
 Problem ten może zostać rozwiązany na przykład poprzez dodanie serwera
 do konwersacji jako uczestnika.
 Serwer ten wykonywałby taki sam kod programu co inni klienci, z jednym
 wyjątkiem — nie miałby możliwości odszyfrowywania wiadomości ani nadawania
 własnych komunikatów.
 Alternatywnym sposobem rozwiązania problemu byłoby powierzenie przekazywania
 wiadomości programom należącym do znajomych użytkowników.
 Oni również nie mieliby możliwości odczytania i modyfikacji treści wiadomości.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\begin_layout Itemize
twarde spacje po jednoliterowych słowach
\end_layout

\begin_layout Itemize
zredagowanie rozdziału
\end_layout

\begin_layout Itemize
inne todosy
\end_layout

\begin_layout Itemize
infohash - kolizje?
\end_layout

\begin_layout Itemize
reużywanie swarmów- w końcu każda wiadomość w konwersacji ma tych samych
 użytkowników - optymalizacja
\end_layout

\begin_layout Itemize
częste usuwanie zbędnych torrentów - strata zasobów, lepszy byłby sposób
 z nadpisywaniem i reużywaniem infohashy, jeśli byłby mechanizm kontroli
 nowych plików w torrencie - nie wyrzucanie starego torrenta i pobieranie
 tego samego, tylko doklejanie do tego co już zostało pobrane nowej treści
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Wyniki testów
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\begin_layout Itemize
środowisko, jakie parametry maszyn, sieci, firewall był/ nie było jeśli
 w sieci domowej to też np różne konfiguracje, 
\end_layout

\begin_layout Itemize
jeden lab, między labami, w domu w jednej sieci, w domu między sieciami
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Wnioski
\end_layout

\begin_layout Standard
\start_of_appendix

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
backmatter
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "messenger"

\end_inset

https://pl-pl.messenger.com/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "messenger-encryption"

\end_inset

https://www.facebook.com/help/messenger-app/811527538946901?helpref=uf_permalink
 (dostęp 13.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bleep"

\end_inset

http://www.bleep.pm/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "signal"

\end_inset

https://whispersystems.org/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "darkwire"

\end_inset

https://darkwire.io/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "friends"

\end_inset

http://moose-team.github.io/friends/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "merkle"

\end_inset

Becker, Georg.
 
\begin_inset Quotes pld
\end_inset

Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis".
 Ruhr-Universität Bochum, 2008, http://www.emsec.rub.de/media/crypto/attachments/fi
les/2011/04/becker_1.pdf (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "tox"

\end_inset

https://tox.chat/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "zeronet"

\end_inset

https://zeronet.readthedocs.io/en/latest/using_zeronet/sample_sites/ (dostęp
 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bitmessage-main"

\end_inset

https://bitmessage.org/wiki/Main_Page (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bitmessage-pdf"

\end_inset

https://bitmessage.org/bitmessage.pdf (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bittorrent"

\end_inset

http://www.bittorrent.org/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "webtorrent"

\end_inset

https://webtorrent.io/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "python-eve"

\end_inset

http://python-eve.org/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bep46-bt"

\end_inset

http://www.bittorrent.org/beps/bep_0046.html (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bep46-wt"

\end_inset

https://github.com/webtorrent/webtorrent/issues/886 (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kademlia-dht"

\end_inset

https://github.com/jeanlauliac/kademlia-dht (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kadtools"

\end_inset

https://github.com/kadtools/kad (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "web cryptography api"

\end_inset

https://developer.mozilla.org/en-US/docs/Web/API/Window/crypto (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "darkwire szyfrowanie how it works"

\end_inset

https://github.com/seripap/darkwire.io#how-it-works (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "signal double ratchet"

\end_inset

Trevor Perrin, Moxie Marlinspike, 
\begin_inset Quotes pld
\end_inset

The Double Ratchet Algorithm
\begin_inset Quotes prd
\end_inset

, 2016, https://whispersystems.org/docs/specifications/doubleratchet/doubleratche
t.pdf (dostęp 13.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bleep forward secrecy"

\end_inset

http://engineering.bittorrent.com/2014/12/11/authentication-and-forward-secrecy-in
-bleep/ (dostęp 14.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bleep forward secrecy offline"

\end_inset

http://engineering.bittorrent.com/2015/08/06/forward-secrecy-for-offline-messages-
in-bleep/ (dostęp 14.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "webCrypto API w3"

\end_inset

https://www.w3.org/TR/WebCryptoAPI/ (dostęp 09.06.2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "webCrypto experimental "

\end_inset

https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API (dostęp 09.06.2017)
\end_layout

\end_body
\end_document
